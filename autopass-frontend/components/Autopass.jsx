import { abi, contractAddresses } from "../constants/index.js"
import { useWeb3Contract, useMoralis } from "react-moralis"
import { useEffect, useState, useRef } from "react"
import { ethers } from "ethers"
import { useNotification } from "web3uikit"
import { Bell } from "@web3uikit/icons"

const Autopass = () => {
  // Extract chainId from useMoralis and rename it to chainIdHex, which is a hexadecimal value, e.g., 0xa123...
  const { chainId: chainIdHex, isWeb3Enabled, Moralis, account, deactivateWeb3 } = useMoralis()
  // Declare a variable chainId (which won't conflict with chainIdHex) and convert the hexadecimal value to decimal
  const chainId = parseInt(chainIdHex)
  // Declare a variable raffleAddress, which is either the contract address associated with the decimal chainId value in contractAddresses.json or null if it is not found
  const raffleAddress = chainId in contractAddresses ? contractAddresses[chainId][0] : null

  // The chainId variable from useMoralis is only retrieved after connecting to a wallet
  let nowChainId = parseInt(chainIdHex)

  // Declare variables using useState, initialized to 0, for entranceFee, numPlayers, recentWinner, contractBalance, playerTimes, winChance, winnerBalance, and ethPrice, respectively
  const [entranceFee, setEntranceFee] = useState("0")
  const [numPlayers, setNumPlayers] = useState(0)
  const [recentWinner, setRecentWinner] = useState("0")
  const [contractBalance, setContractBalance] = useState("0")
  const [playerTimes, setPlayerTimes] = useState(0)
  const [winChance, setWinChance] = useState("0")
  const [winnerBalance, setWinnerBalance] = useState("0")
  const [ethPrice, setEthPrice] = useState("0")

  // Call the getEntranceFee view function from the Raffle contract using the Moralis useWeb3Contract hook to retrieve the minimum entrance fee
  const { runContractFunction: getEntranceFee } = useWeb3Contract({
    abi: abi, // abi.json is generated by deploying the contract and made available to the frontend
    contractAddress: raffleAddress, // contractAddresses.json is generated by deploying the contract and made available to the frontend, and the contract address is retrieved using the chainId
    functionName: "getEntranceFee",
    params: {}, // This is a view function, so there are no input parameters
  })

  // Function to deposit funds into the contract
  const {
    runContractFunction: enterRaffle,
    isLoading,
    isFetching,
  } = useWeb3Contract({
    abi: abi,
    contractAddress: raffleAddress,
    functionName: "enterRaffle",
    params: {},
    msgValue: entranceFee,
  })

  // Use the getNumberOfPlayers function from the Raffle contract to display the number of participants
  const { runContractFunction: getNumberOfPlayers } = useWeb3Contract({
    abi: abi,
    contractAddress: raffleAddress,
    functionName: "getNumberOfPlayers",
    params: {},
  })

  // Show the address of the most recent winner
  const { runContractFunction: getRecentWinner } = useWeb3Contract({
    abi: abi,
    contractAddress: raffleAddress,
    functionName: "getRecentWinner",
    params: {},
  })

  // Show how many times the current account has entered the raffle, currently undefined
  const { runContractFunction: getPlayerTimes } = useWeb3Contract({
    abi: abi,
    contractAddress: raffleAddress,
    functionName: "getPlayerTimes",
    params: {},
  })

  // Show how much money the winner received
  const { runContractFunction: getWinnerBalance } = useWeb3Contract({
    abi: abi,
    contractAddress: raffleAddress,
    functionName: "getWinnerBalance",
    params: {},
  })

  // Show the price of ether
  const { runContractFunction: getPrice } = useWeb3Contract({
    abi: abi,
    contractAddress: raffleAddress,
    functionName: "getPrice",
    params: {},
  })

  //Fetches the current balance of the contract
  async function getContractBalance() {
    const provider = new ethers.providers.Web3Provider(window.ethereum)
    //Uses provider to fetch the balance, passing in the contract address
    const balance = await provider.getBalance(raffleAddress)
    //console.log(`None format balance is ${balance}`);
    //console.log(`Contract balance is ${ethers.utils.formatEther(balance)}`);
    return balance
  }

  // Display winning probability after deposit
  async function getWinChance() {
    const a = (await getPlayerTimes()).toNumber()
    const b = (await getNumberOfPlayers()).toNumber()
    if (a != 0 && b != 0) {
      const percent = (a / b) * 10000
      const round = Math.round(percent) / 100
      const chance = round + "%"
      return chance
    }
  }

  // When this function is called, call the contract to get values and update them in State
  async function UpdateUI() {
    if (nowChainId == 5) {
      // Use try-catch to ensure the webpage continues running.
      // The writing style uses a ternary operator to check if the object exists. If not, pass an empty value.
      try {
        const entranceFeeFromCall = (await getEntranceFee())
          ? (await getEntranceFee()).toString()
          : ""
        const numPlayersFromCall = (await getNumberOfPlayers())
          ? (await getNumberOfPlayers()).toNumber()
          : ""
        const recentWinnerFromCall = (await getRecentWinner()) ? await getRecentWinner() : ""
        const contractBalanceFromCall = (await getContractBalance())
          ? (await getContractBalance()).toString()
          : ""
        const playerTimesFromCall = (await getPlayerTimes())
          ? (await getPlayerTimes()).toNumber()
          : ""
        const winnerBalanceFromCall = (await getWinnerBalance())
          ? (await getWinnerBalance()).toString()
          : ""
        const ethPriceFromCall = (await getPrice()) ? (await getPrice()).toString() : ""
        setEntranceFee(entranceFeeFromCall)
        setNumPlayers(numPlayersFromCall)
        setRecentWinner(recentWinnerFromCall)
        setContractBalance(contractBalanceFromCall)
        setPlayerTimes(playerTimesFromCall)
        setWinnerBalance(winnerBalanceFromCall)
        setEthPrice(ethPriceFromCall)
        const winChanceFromCall = (await getWinChance()) ? await getWinChance() : ""
        setWinChance(winChanceFromCall)
      } catch (error) {
        console.log(error)
      }
    }
  }

  // Ethereum to USD conversion function
  function priceConvert(fees) {
    fees = fees || "0x0"
    const a = ethers.utils.formatUnits(fees, "ether")
    const b = ethers.utils.formatUnits(ethPrice, "ether")
    const percent = a * b * 100
    const round = Math.round(percent) / 100
    return round
  }

  // Switch network function
  async function swtichNetwork(chain) {
    const chainIdHex = await Moralis.switchNetwork(chain)
    return chainIdHex
  }

  // useEffect hook to call view function and get deposit amount
  // Triggered after the page has loaded and when MetaMask is connected
  // Does not call getEntranceFee on the first page load when the user is not connected to a wallet
  // Include isWeb3Enabled in the dependency array to trigger this useEffect when the wallet is connected
  // This useEffect is triggered every time the account is connected or disconnected
  useEffect(() => {
    if (isWeb3Enabled) {
      UpdateUI()
    }
  }, [isWeb3Enabled])

  // useEffect hook that runs only once after the page refreshes
  useEffect(() => {
    // When an account change is detected after connecting to a wallet
    Moralis.onAccountChanged((account) => {
      // If the account is empty, it may have been disconnected manually, so deactivateWeb3
      if (account == null) {
        deactivateWeb3()
      } else if (account != null) {
        UpdateUI()
      }
    })
  }, [])

  useEffect(() => {
    // When a chain change is detected after connecting to a wallet
    Moralis.onChainChanged((chain) => {
      const chainIdHex = swtichNetwork(chain)
      nowChainId = parseInt(chainIdHex)
      UpdateUI()
    })
  }, [])

  // JsonRpcProvider and Contract objects
  const provider = new ethers.providers.JsonRpcProvider(
    "https://eth-goerli.g.alchemy.com/v2/eO-4t0dSBC3mQckIv5zVo90O_yV6H95k"
  )
  const CONTRACT_ADDR = "0xfA28691A9dFB27173B50Baa343a3CD35138a3932"
  const contract = new ethers.Contract(CONTRACT_ADDR, abi, provider)

  // Event handlers for the Contract object
  const handleWinnerPickedEvent = async () => {
    console.log("found event WinnerPicked")
    if (isWeb3Enabled) {
      UpdateUI()
    }
  }

  const handleRequestEvent = async () => {
    console.log("found event RequestedRaffleWinner")
  }

  const handleRaffleEnterEvent = async () => {
    console.log("found event Raffle Enter")
  }

  // useEffect hook to add and remove listeners for the Contract events
  useEffect(() => {
    contract.on("WinnerPicked", handleWinnerPickedEvent)
    contract.on("RequestedRaffleWinner", handleRequestEvent)
    contract.on("RaffleEnter", handleRaffleEnterEvent)
    return () => {
      contract.removeAllListeners("WinnerPicked")
      contract.removeAllListeners("RequestedRaffleWinner")
      contract.removeAllListeners("RaffleEnter")
    }
  }, [])

  // useNotification hook for dispatching notifications
  const dispatch = useNotification()

  // Async function to handle successful enterRaffle onClick calls
  const handleSuccess = async function (tx) {
    // Wait for one block confirmation
    await tx.wait(1)
    // Trigger another function
    handleNewNotification(tx)
    // Update UI after successful deposit
    UpdateUI()
  }

  const handleError = async function (error) {
    // console.log(error);
    // const contractState = await getRaffleState()
    // console.log(`contract State : ${contractState}`);
    handleErrorNotification()
  }

  // This function is called by handleSuccess and is a general function
  // Call dispatch of useNotification and pass in the format of the notification to be sent
  // Refer to https://web3ui.github.io/web3uikit/?path=/docs/5-popup-notification--hook-demo
  const handleNewNotification = function () {
    // The object passed to dispatch is an object
    dispatch({
      type: "info",
      message: "Transaction successful!",
      title: "Transaction Notification",
      position: "topR",
      icon: <Bell fontSize="50px" />,
    })
  }

  const handleErrorNotification = function () {
    // The object passed to dispatch is an object
    dispatch({
      type: "error",
      message: "Transaction failed.",
      title: "Transaction Notification",
      position: "topR",
      icon: <Bell fontSize="50px" />,
    })
  }

  const callEnterRaffle = async () => {
    try {
      await enterRaffle({
        onSuccess: handleSuccess,
        onError: handleError,
      })
    } catch (error) {
      handleErrorNotification()
      console.log(error)
    }
  }

  return (
    <div className="p-5 rounded-lg bg-slate-100">
      {isWeb3Enabled ? (
        nowChainId == 5 ? (
          <div class="flex items-center space-x-4">
            <div>
              Parking cost: {ethers.utils.formatUnits(entranceFee, "ether")} ETH (
              {priceConvert(entranceFee)} TWD)
            </div>
            <button
              className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
              onClick={callEnterRaffle}
              disabled={isLoading || isFetching}
            >
              {isLoading || isFetching ? (
                <div className="animate-spin spinner-border h-8 w-8 border-b-2 rounded-full"></div>
              ) : (
                <div>Pay Now</div>
              )}
            </button>
          </div>
        ) : (
          <div className="text-blue-600 hover:underline font-medium">Wrong chain</div>
        )
      ) : (
        <div className="text-rose-500 hover:underline font-medium">No web3 wallet</div>
      )}
    </div>
  )
}

export default Autopass
